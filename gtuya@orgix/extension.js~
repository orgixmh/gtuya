const St = imports.gi.St;
const PopupMenu = imports.ui.popupMenu;
const GObject = imports.gi.GObject;
const Clutter = imports.gi.Clutter;
const Me = imports.misc.extensionUtils.getCurrentExtension();
const Gio = imports.gi.Gio;
const Util = imports.misc.util;
const Main = imports.ui.main;
const Soup = imports.gi.Soup;
const GLib = imports.gi.GLib;
const byteArray = imports.byteArray;
const loop = GLib.MainLoop.new(null, false);




xStatIndicator = {

    indicators: [],
    session: null,
    message: null,
    connx: null,
    connxTimeout: null,
    serverUri: 'ws://localhost:3000/test/?EIO=3&transport=websocket',


    connect: function(){
        
       // if (this.connx==null){
            clearTimeout(xStatIndicator.connxTimeout); //in a case of double run
            xStatIndicator.session = new Soup.Session();
            xStatIndicator.message = new Soup.Message({
                method: 'GET',
                uri: Soup.URI.new('ws://localhost:3000/test/?EIO=3&transport=websocket'),
            });

            xStatIndicator.session.websocket_connect_async(xStatIndicator.message, 'origin', [], null, xStatIndicator.connection);

      //  }
    },

    connection: function(_session, res) {
        
        try {
            
            xStatIndicator.connx = xStatIndicator.session.websocket_connect_finish(res);
            xStatIndicator.connx.connect('message', (self, type, data) => {
                if (type !== Soup.WebsocketDataType.TEXT)
                    return;

                xStatIndicator.handleServerData(byteArray.toString(byteArray.fromGBytes(data)));
                
            });
        } catch (e) {
            logError(e, 'ExtensionError');
            xStatIndicator.test();
            xStatIndicator.connxTimeout = setTimeout(xStatIndicator.connect, 3000);
            xStatIndicator.connx = null;
            return;
        }

                xStatIndicator.connx.connect('closed', () => {
                //xStatIndicator.test();
                xStatIndicator.connxTimeout = setTimeout(xStatIndicator.connect, 3000);
                xStatIndicator.connx = null;
            });
            xStatIndicator.connx.connect('error', () => {
                //xStatIndicator.test();
                xStatIndicator.connxTimeout = setTimeout(xStatIndicator.connect, 3000);
                xStatIndicator.connx = null;
            });

            xStatIndicator.connx.send_text("{ \"command\": \"indicatorReady\" }");
    
    },

    handleServerData: function(data){
        try {
            decodedData = JSON.parse(data);
        }
        catch (e) {
            return 0;
        }
        this.connx.send_text("|"+decodedData.command+"|");
        
        switch(decodedData.command) {
            case "clearIndicators":
                this.clearIndicators();
                break;
            case "updateIndicator":
                this.updateIndicator(decodedData);
                break;
            case "createIndicators":
                this.createIndicators(decodedData.indicators);
                break;
            default:
                break;
       
         }
   
    },
    trigged: function(event,id){
        xStatIndicator.connx.send_text("{ \"command\": \"openMenu\", \"menu\": \""+ xStatIndicator.indicators[id].id +"\"}");
    },

    createIndicators: function(data){
	icondsdsd="iVBORw0KGgoAAAANSUhEUgAAAFAAAAAeAQMAAACBjQvyAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAANQTFRFALgadgTgEAAAAA1JREFUeJxjYBgF1AEAAUoAAaqan9wAAAAASUVORK5CYII=";
        this.clearIndicators();
        let i=0;
        while(i<data.length){
            let indicatorID = this.indicators.length;
            	    
            this.indicators[indicatorID] = data[i];
            this.indicators[indicatorID].menu = new St.Bin({ style_class: 'panel-button', width: 80, reactive: true,can_focus: true,track_hover: true });
            this.indicators[indicatorID].gicon = Gio.BytesIcon.new(GLib.base64_decode(icondsdsd));            
            this.indicators[indicatorID].icon = new St.Icon ({ gicon:this.indicators[indicatorID].gicon, style_class: 'xstats-icon' });
	      this.indicators[indicatorID].icon.icon_size = 80;
	      this.indicators[indicatorID].icon.height = 30;
	      this.indicators[indicatorID].icon.width = 80;
            this.indicators[indicatorID].menu.connect('button-press-event', function(selft, event, mid = indicatorID){xStatIndicator.trigged(event, mid);});
            this.indicators[indicatorID].menu.set_child(this.indicators[indicatorID].icon);
            this.indicators[indicatorID].updateIcon = function(id) { 
                xStatIndicator.indicators[id].gicon = Gio.BytesIcon.new(GLib.base64_decode(icondsdsd));
                xStatIndicator.indicators[id].icon = new St.Icon ({ gicon:xStatIndicator.indicators[id].gicon, style_class: 'xstats-icon'});
                xStatIndicator.indicators[id].menu.set_child(xStatIndicator.indicators[id].icon)
                //xStatIndicator.indicators[indicatorID].icon.set_icon_size(80,30);
                xStatIndicator.indicators[indicatorID].icon.set_height(30);
            }
            Main.panel._rightBox.insert_child_at_index(this.indicators[indicatorID].menu,i);
            i++;
        }
    },
    
    updateIndicator: function(data){
        let i=0;
        while(i<this.indicators.length){
            if (this.indicators[i].id == data.id){
                this.indicators[i].data = data.data;
                this.indicators[i].updateIcon(i);
            }
            i++;
        }
    },
    
    clearIndicators: function(){
        while(this.indicators.length > 0){
            Main.panel._rightBox.remove_actor(this.indicators[0].menu);
            delete(this.indicators[0].gicon)
            delete(this.indicators[0].icon)
            delete(this.indicators[0].menu)
            this.indicators.splice(0, 1);
        }
    },
    closeConnection: function(){
        this.connx.close(Soup.WebsocketCloseCode.NORMAL, null);
    }
}


var clearTimeout, clearInterval;
clearTimeout = clearInterval = GLib.Source.remove;


function setTimeout(func, delay, ...args) {
    const wrappedFunc = () => {
        func.apply(this, args);
    };
    return GLib.timeout_add(GLib.PRIORITY_DEFAULT, delay, wrappedFunc);
}

function setInterval(func, delay, ...args) {
    const wrappedFunc = () => {
        return func.apply(this, args) || true;
    };
    return GLib.timeout_add(GLib.PRIORITY_DEFAULT, delay, wrappedFunc);
}


function init() {
    //xStatIndicator.init();
}


function enable () {
    xStatIndicator.connect();
 

}

function disable () {
    xStatIndicator.clearIndicators();
   xStatIndicator.closeConnection();
}
